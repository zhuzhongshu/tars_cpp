// **********************************************************************
// This file was generated by a TARS parser!
// TARS version 1.1.0.
// **********************************************************************

#ifndef __AUTH_H_
#define __AUTH_H_

#include <map>
#include <string>
#include <vector>
#include "tup/Tars.h"
#include "tup/TarsJson.h"
using namespace std;


namespace tars
{
    enum AUTH_STATE
    {
        AUTH_INIT = -127,
        AUTH_SUCC = 0,
        AUTH_PROTO_ERR = -100,
        AUTH_WRONG_OBJ = -101,
        AUTH_WRONG_AK = -102,
        AUTH_WRONG_TIME = -103,
        AUTH_NOT_SUPPORT_ENC = -104,
        AUTH_DEC_FAIL = -105,
        AUTH_ERROR = -106,
    };
    inline string etos(const AUTH_STATE & e)
    {
        switch(e)
        {
            case AUTH_INIT: return "AUTH_INIT";
            case AUTH_SUCC: return "AUTH_SUCC";
            case AUTH_PROTO_ERR: return "AUTH_PROTO_ERR";
            case AUTH_WRONG_OBJ: return "AUTH_WRONG_OBJ";
            case AUTH_WRONG_AK: return "AUTH_WRONG_AK";
            case AUTH_WRONG_TIME: return "AUTH_WRONG_TIME";
            case AUTH_NOT_SUPPORT_ENC: return "AUTH_NOT_SUPPORT_ENC";
            case AUTH_DEC_FAIL: return "AUTH_DEC_FAIL";
            case AUTH_ERROR: return "AUTH_ERROR";
            default: return "";
        }
    }
    inline int stoe(const string & s, AUTH_STATE & e)
    {
        if(s == "AUTH_INIT")  { e=AUTH_INIT; return 0;}
        if(s == "AUTH_SUCC")  { e=AUTH_SUCC; return 0;}
        if(s == "AUTH_PROTO_ERR")  { e=AUTH_PROTO_ERR; return 0;}
        if(s == "AUTH_WRONG_OBJ")  { e=AUTH_WRONG_OBJ; return 0;}
        if(s == "AUTH_WRONG_AK")  { e=AUTH_WRONG_AK; return 0;}
        if(s == "AUTH_WRONG_TIME")  { e=AUTH_WRONG_TIME; return 0;}
        if(s == "AUTH_NOT_SUPPORT_ENC")  { e=AUTH_NOT_SUPPORT_ENC; return 0;}
        if(s == "AUTH_DEC_FAIL")  { e=AUTH_DEC_FAIL; return 0;}
        if(s == "AUTH_ERROR")  { e=AUTH_ERROR; return 0;}

        return -1;
    }

    enum AUTH_TYPE
    {
        AUTH_TYPENONE = 0,
        AUTH_TYPELOCAL = 1,
    };
    inline string etos(const AUTH_TYPE & e)
    {
        switch(e)
        {
            case AUTH_TYPENONE: return "AUTH_TYPENONE";
            case AUTH_TYPELOCAL: return "AUTH_TYPELOCAL";
            default: return "";
        }
    }
    inline int stoe(const string & s, AUTH_TYPE & e)
    {
        if(s == "AUTH_TYPENONE")  { e=AUTH_TYPENONE; return 0;}
        if(s == "AUTH_TYPELOCAL")  { e=AUTH_TYPELOCAL; return 0;}

        return -1;
    }

    struct BasicAuthInfo : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "tars.BasicAuthInfo";
        }
        static string MD5()
        {
            return "55420b345e13da84aad635417b0d3f4b";
        }
        BasicAuthInfo()
        :sObjName(""),sAccessKey(""),sSecretKey(""),sHashSecretKey2("")
        {
        }
        void resetDefautlt()
        {
            sObjName = "";
            sAccessKey = "";
            sSecretKey = "";
            sHashSecretKey2 = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (sObjName != "")
            {
                _os.write(sObjName, 1);
            }
            if (sAccessKey != "")
            {
                _os.write(sAccessKey, 2);
            }
            if (sSecretKey != "")
            {
                _os.write(sSecretKey, 3);
            }
            if (sHashSecretKey2 != "")
            {
                _os.write(sHashSecretKey2, 4);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(sObjName, 1, false);
            _is.read(sAccessKey, 2, false);
            _is.read(sSecretKey, 3, false);
            _is.read(sHashSecretKey2, 4, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            if (sObjName != "")
            {
                p->value["sObjName"] = tars::JsonOutput::writeJson(sObjName);
            }
            if (sAccessKey != "")
            {
                p->value["sAccessKey"] = tars::JsonOutput::writeJson(sAccessKey);
            }
            if (sSecretKey != "")
            {
                p->value["sSecretKey"] = tars::JsonOutput::writeJson(sSecretKey);
            }
            if (sHashSecretKey2 != "")
            {
                p->value["sHashSecretKey2"] = tars::JsonOutput::writeJson(sHashSecretKey2);
            }
            return p;
        }
        string writeToJsonString()
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(sObjName,pObj->value["sObjName"], false);
            tars::JsonInput::readJson(sAccessKey,pObj->value["sAccessKey"], false);
            tars::JsonInput::readJson(sSecretKey,pObj->value["sSecretKey"], false);
            tars::JsonInput::readJson(sHashSecretKey2,pObj->value["sHashSecretKey2"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(sObjName,"sObjName");
            _ds.display(sAccessKey,"sAccessKey");
            _ds.display(sSecretKey,"sSecretKey");
            _ds.display(sHashSecretKey2,"sHashSecretKey2");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(sObjName, true);
            _ds.displaySimple(sAccessKey, true);
            _ds.displaySimple(sSecretKey, true);
            _ds.displaySimple(sHashSecretKey2, false);
            return _os;
        }
    public:
        std::string sObjName;
        std::string sAccessKey;
        std::string sSecretKey;
        std::string sHashSecretKey2;
    };
    inline bool operator==(const BasicAuthInfo&l, const BasicAuthInfo&r)
    {
        return l.sObjName == r.sObjName && l.sAccessKey == r.sAccessKey && l.sSecretKey == r.sSecretKey && l.sHashSecretKey2 == r.sHashSecretKey2;
    }
    inline bool operator!=(const BasicAuthInfo&l, const BasicAuthInfo&r)
    {
        return !(l == r);
    }

    struct BasicAuthPackage : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "tars.BasicAuthPackage";
        }
        static string MD5()
        {
            return "aec8c996fb516fda7f88937d6a625c14";
        }
        BasicAuthPackage()
        :sObjName(""),sAccessKey(""),iTime(0),sHashMethod("sha1"),sSignature("")
        {
        }
        void resetDefautlt()
        {
            sObjName = "";
            sAccessKey = "";
            iTime = 0;
            sHashMethod = "sha1";
            sSignature = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(sObjName, 1);
            _os.write(sAccessKey, 2);
            _os.write(iTime, 3);
            if (sHashMethod != "sha1")
            {
                _os.write(sHashMethod, 4);
            }
            if (sSignature != "")
            {
                _os.write(sSignature, 5);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(sObjName, 1, true);
            _is.read(sAccessKey, 2, true);
            _is.read(iTime, 3, true);
            _is.read(sHashMethod, 4, false);
            _is.read(sSignature, 5, false);
        }
        tars::JsonValueObjPtr writeToJson() const
        {
            tars::JsonValueObjPtr p = new tars::JsonValueObj();
            p->value["sObjName"] = tars::JsonOutput::writeJson(sObjName);
            p->value["sAccessKey"] = tars::JsonOutput::writeJson(sAccessKey);
            p->value["iTime"] = tars::JsonOutput::writeJson(iTime);
            if (sHashMethod != "sha1")
            {
                p->value["sHashMethod"] = tars::JsonOutput::writeJson(sHashMethod);
            }
            if (sSignature != "")
            {
                p->value["sSignature"] = tars::JsonOutput::writeJson(sSignature);
            }
            return p;
        }
        string writeToJsonString()
        {
            return tars::TC_Json::writeValue(writeToJson());
        }
        void readFromJson(const tars::JsonValuePtr & p, bool isRequire = true)
        {
            resetDefautlt();
            if(NULL == p.get() || p->getType() != tars::eJsonTypeObj)
            {
                char s[128];
                snprintf(s, sizeof(s), "read 'struct' type mismatch, get type: %d.", (p.get() ? p->getType() : 0));
                throw tars::TC_Json_Exception(s);
            }
            tars::JsonValueObjPtr pObj=tars::JsonValueObjPtr::dynamicCast(p);
            tars::JsonInput::readJson(sObjName,pObj->value["sObjName"], true);
            tars::JsonInput::readJson(sAccessKey,pObj->value["sAccessKey"], true);
            tars::JsonInput::readJson(iTime,pObj->value["iTime"], true);
            tars::JsonInput::readJson(sHashMethod,pObj->value["sHashMethod"], false);
            tars::JsonInput::readJson(sSignature,pObj->value["sSignature"], false);
        }
        void readFromJsonString(const string & str)
        {
            readFromJson(tars::TC_Json::getValue(str));
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(sObjName,"sObjName");
            _ds.display(sAccessKey,"sAccessKey");
            _ds.display(iTime,"iTime");
            _ds.display(sHashMethod,"sHashMethod");
            _ds.display(sSignature,"sSignature");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(sObjName, true);
            _ds.displaySimple(sAccessKey, true);
            _ds.displaySimple(iTime, true);
            _ds.displaySimple(sHashMethod, true);
            _ds.displaySimple(sSignature, false);
            return _os;
        }
    public:
        std::string sObjName;
        std::string sAccessKey;
        tars::Int64 iTime;
        std::string sHashMethod;
        std::string sSignature;
    };
    inline bool operator==(const BasicAuthPackage&l, const BasicAuthPackage&r)
    {
        return l.sObjName == r.sObjName && l.sAccessKey == r.sAccessKey && l.iTime == r.iTime && l.sHashMethod == r.sHashMethod && l.sSignature == r.sSignature;
    }
    inline bool operator!=(const BasicAuthPackage&l, const BasicAuthPackage&r)
    {
        return !(l == r);
    }


}



#endif
