// **********************************************************************
// This file was generated by a TARS parser!
// TARS version 1.1.0.
// **********************************************************************

#ifndef __NODE_H_
#define __NODE_H_

#include <map>
#include <string>
#include <vector>
#include "tup/Tars.h"
#include "tup/TarsJson.h"
using namespace std;
#include "NodeDescriptor.h"
#include "RegistryDescriptor.h"
#include "servant/ServantProxy.h"
#include "servant/Servant.h"
#include "promise/promise.h"


namespace tars
{

    /* callback of async proxy for client */
    class NodePrxCallback: public tars::ServantProxyCallback
    {
    public:
        virtual ~NodePrxCallback(){}
        virtual void callback_addFile(tars::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_addFile() override incorrect."); }
        virtual void callback_addFile_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_addFile_exception() override incorrect."); }

        virtual void callback_delCache(tars::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_delCache() override incorrect."); }
        virtual void callback_delCache_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_delCache_exception() override incorrect."); }

        virtual void callback_destroyServer(tars::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_destroyServer() override incorrect."); }
        virtual void callback_destroyServer_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_destroyServer_exception() override incorrect."); }

        virtual void callback_getLoad(const tars::LoadInfo& ret)
        { throw std::runtime_error("callback_getLoad() override incorrect."); }
        virtual void callback_getLoad_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getLoad_exception() override incorrect."); }

        virtual void callback_getName(const std::string& ret)
        { throw std::runtime_error("callback_getName() override incorrect."); }
        virtual void callback_getName_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getName_exception() override incorrect."); }

        virtual void callback_getPatchPercent(tars::Int32 ret,  const tars::PatchInfo& tPatchInfo)
        { throw std::runtime_error("callback_getPatchPercent() override incorrect."); }
        virtual void callback_getPatchPercent_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getPatchPercent_exception() override incorrect."); }

        virtual void callback_getServerPid(tars::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_getServerPid() override incorrect."); }
        virtual void callback_getServerPid_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getServerPid_exception() override incorrect."); }

        virtual void callback_getSettingState(tars::ServerState ret,  const std::string& result)
        { throw std::runtime_error("callback_getSettingState() override incorrect."); }
        virtual void callback_getSettingState_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getSettingState_exception() override incorrect."); }

        virtual void callback_getState(tars::ServerState ret,  const std::string& result)
        { throw std::runtime_error("callback_getState() override incorrect."); }
        virtual void callback_getState_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getState_exception() override incorrect."); }

        virtual void callback_getStateInfo(tars::Int32 ret,  const tars::ServerStateInfo& info,  const std::string& result)
        { throw std::runtime_error("callback_getStateInfo() override incorrect."); }
        virtual void callback_getStateInfo_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getStateInfo_exception() override incorrect."); }

        virtual void callback_getUnusedShmKeys(tars::Int32 ret,  const vector<tars::Int32>& shm_keys)
        { throw std::runtime_error("callback_getUnusedShmKeys() override incorrect."); }
        virtual void callback_getUnusedShmKeys_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_getUnusedShmKeys_exception() override incorrect."); }

        virtual void callback_loadServer(tars::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_loadServer() override incorrect."); }
        virtual void callback_loadServer_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_loadServer_exception() override incorrect."); }

        virtual void callback_notifyServer(tars::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_notifyServer() override incorrect."); }
        virtual void callback_notifyServer_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_notifyServer_exception() override incorrect."); }

        virtual void callback_patchPro(tars::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_patchPro() override incorrect."); }
        virtual void callback_patchPro_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_patchPro_exception() override incorrect."); }

        virtual void callback_shutdown(tars::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_shutdown() override incorrect."); }
        virtual void callback_shutdown_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_shutdown_exception() override incorrect."); }

        virtual void callback_startServer(tars::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_startServer() override incorrect."); }
        virtual void callback_startServer_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_startServer_exception() override incorrect."); }

        virtual void callback_stopAllServers(tars::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_stopAllServers() override incorrect."); }
        virtual void callback_stopAllServers_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_stopAllServers_exception() override incorrect."); }

        virtual void callback_stopServer(tars::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_stopServer() override incorrect."); }
        virtual void callback_stopServer_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_stopServer_exception() override incorrect."); }

        virtual void callback_synState(tars::Int32 ret,  const std::string& result)
        { throw std::runtime_error("callback_synState() override incorrect."); }
        virtual void callback_synState_exception(tars::Int32 ret)
        { throw std::runtime_error("callback_synState_exception() override incorrect."); }

    public:
        virtual const map<std::string, std::string> & getResponseContext() const
        {
            CallbackThreadData * pCbtd = CallbackThreadData::getData();
            assert(pCbtd != NULL);

            if(!pCbtd->getContextValid())
            {
                throw TC_Exception("cann't get response context");
            }
            return pCbtd->getResponseContext();
        }

    public:
        virtual int onDispatch(tars::ReqMessagePtr msg)
        {
            static ::std::string __Node_all[]=
            {
                "addFile",
                "delCache",
                "destroyServer",
                "getLoad",
                "getName",
                "getPatchPercent",
                "getServerPid",
                "getSettingState",
                "getState",
                "getStateInfo",
                "getUnusedShmKeys",
                "loadServer",
                "notifyServer",
                "patchPro",
                "shutdown",
                "startServer",
                "stopAllServers",
                "stopServer",
                "synState"
            };
            pair<string*, string*> r = equal_range(__Node_all, __Node_all+19, string(msg->request.sFuncName));
            if(r.first == r.second) return tars::TARSSERVERNOFUNCERR;
            switch(r.first - __Node_all)
            {
                case 0:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_addFile_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 4, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_addFile(_ret, result);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_delCache_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 4, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_delCache(_ret, result);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_destroyServer_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 3, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_destroyServer(_ret, result);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getLoad_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::LoadInfo _ret;
                    _is.read(_ret, 0, true);

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_getLoad(_ret);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 4:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getName_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    std::string _ret;
                    _is.read(_ret, 0, true);

                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_getName(_ret);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 5:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getPatchPercent_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    tars::PatchInfo tPatchInfo;
                    _is.read(tPatchInfo, 3, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_getPatchPercent(_ret, tPatchInfo);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 6:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getServerPid_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 3, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_getServerPid(_ret, result);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 7:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getSettingState_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::ServerState _ret = tars::Inactive;;
                    tars::Int32 eTemp0 = tars::Inactive;
                    _is.read(eTemp0, 0, true);
                    _ret = (tars::ServerState)eTemp0;

                    std::string result;
                    _is.read(result, 3, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_getSettingState(_ret, result);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 8:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getState_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::ServerState _ret = tars::Inactive;;
                    tars::Int32 eTemp0 = tars::Inactive;
                    _is.read(eTemp0, 0, true);
                    _ret = (tars::ServerState)eTemp0;

                    std::string result;
                    _is.read(result, 3, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_getState(_ret, result);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 9:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getStateInfo_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    tars::ServerStateInfo info;
                    _is.read(info, 3, true);
                    std::string result;
                    _is.read(result, 4, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_getStateInfo(_ret, info, result);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 10:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getUnusedShmKeys_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    vector<tars::Int32> shm_keys;
                    _is.read(shm_keys, 2, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_getUnusedShmKeys(_ret, shm_keys);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 11:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_loadServer_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 3, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_loadServer(_ret, result);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 12:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_notifyServer_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 4, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_notifyServer(_ret, result);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 13:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_patchPro_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 2, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_patchPro(_ret, result);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 14:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_shutdown_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 1, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_shutdown(_ret, result);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 15:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_startServer_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 3, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_startServer(_ret, result);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 16:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_stopAllServers_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 1, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_stopAllServers(_ret, result);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 17:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_stopServer_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 3, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_stopServer(_ret, result);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
                case 18:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_synState_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    tars::Int32 _ret;
                    _is.read(_ret, 0, true);

                    std::string result;
                    _is.read(result, 3, true);
                    CallbackThreadData * pCbtd = CallbackThreadData::getData();
                    assert(pCbtd != NULL);

                    pCbtd->setResponseContext(msg->response.context);

                    callback_synState(_ret, result);

                    pCbtd->delResponseContext();

                    return tars::TARSSERVERSUCCESS;

                }
            }
            return tars::TARSSERVERNOFUNCERR;
        }

    };
    typedef tars::TC_AutoPtr<NodePrxCallback> NodePrxCallbackPtr;

    /* callback of promise async proxy for client */
    class NodePrxCallbackPromise: public tars::ServantProxyCallback
    {
    public:
        virtual ~NodePrxCallbackPromise(){}
    public:
        struct PromiseaddFile: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< NodePrxCallbackPromise::PromiseaddFile > PromiseaddFilePtr;

        NodePrxCallbackPromise(const promise::Promise< NodePrxCallbackPromise::PromiseaddFilePtr > &promise)
        : _promise_addFile(promise)
        {}
        
        virtual void callback_addFile(const NodePrxCallbackPromise::PromiseaddFilePtr &ptr)
        {
            _promise_addFile.setValue(ptr);
        }
        virtual void callback_addFile_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:addFile_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_addFile.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< NodePrxCallbackPromise::PromiseaddFilePtr > _promise_addFile;

    public:
        struct PromisedelCache: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< NodePrxCallbackPromise::PromisedelCache > PromisedelCachePtr;

        NodePrxCallbackPromise(const promise::Promise< NodePrxCallbackPromise::PromisedelCachePtr > &promise)
        : _promise_delCache(promise)
        {}
        
        virtual void callback_delCache(const NodePrxCallbackPromise::PromisedelCachePtr &ptr)
        {
            _promise_delCache.setValue(ptr);
        }
        virtual void callback_delCache_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:delCache_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_delCache.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< NodePrxCallbackPromise::PromisedelCachePtr > _promise_delCache;

    public:
        struct PromisedestroyServer: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< NodePrxCallbackPromise::PromisedestroyServer > PromisedestroyServerPtr;

        NodePrxCallbackPromise(const promise::Promise< NodePrxCallbackPromise::PromisedestroyServerPtr > &promise)
        : _promise_destroyServer(promise)
        {}
        
        virtual void callback_destroyServer(const NodePrxCallbackPromise::PromisedestroyServerPtr &ptr)
        {
            _promise_destroyServer.setValue(ptr);
        }
        virtual void callback_destroyServer_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:destroyServer_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_destroyServer.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< NodePrxCallbackPromise::PromisedestroyServerPtr > _promise_destroyServer;

    public:
        struct PromisegetLoad: virtual public TC_HandleBase
        {
        public:
            tars::LoadInfo _ret;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< NodePrxCallbackPromise::PromisegetLoad > PromisegetLoadPtr;

        NodePrxCallbackPromise(const promise::Promise< NodePrxCallbackPromise::PromisegetLoadPtr > &promise)
        : _promise_getLoad(promise)
        {}
        
        virtual void callback_getLoad(const NodePrxCallbackPromise::PromisegetLoadPtr &ptr)
        {
            _promise_getLoad.setValue(ptr);
        }
        virtual void callback_getLoad_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getLoad_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getLoad.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< NodePrxCallbackPromise::PromisegetLoadPtr > _promise_getLoad;

    public:
        struct PromisegetName: virtual public TC_HandleBase
        {
        public:
            std::string _ret;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< NodePrxCallbackPromise::PromisegetName > PromisegetNamePtr;

        NodePrxCallbackPromise(const promise::Promise< NodePrxCallbackPromise::PromisegetNamePtr > &promise)
        : _promise_getName(promise)
        {}
        
        virtual void callback_getName(const NodePrxCallbackPromise::PromisegetNamePtr &ptr)
        {
            _promise_getName.setValue(ptr);
        }
        virtual void callback_getName_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getName_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getName.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< NodePrxCallbackPromise::PromisegetNamePtr > _promise_getName;

    public:
        struct PromisegetPatchPercent: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            tars::PatchInfo tPatchInfo;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< NodePrxCallbackPromise::PromisegetPatchPercent > PromisegetPatchPercentPtr;

        NodePrxCallbackPromise(const promise::Promise< NodePrxCallbackPromise::PromisegetPatchPercentPtr > &promise)
        : _promise_getPatchPercent(promise)
        {}
        
        virtual void callback_getPatchPercent(const NodePrxCallbackPromise::PromisegetPatchPercentPtr &ptr)
        {
            _promise_getPatchPercent.setValue(ptr);
        }
        virtual void callback_getPatchPercent_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getPatchPercent_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getPatchPercent.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< NodePrxCallbackPromise::PromisegetPatchPercentPtr > _promise_getPatchPercent;

    public:
        struct PromisegetServerPid: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< NodePrxCallbackPromise::PromisegetServerPid > PromisegetServerPidPtr;

        NodePrxCallbackPromise(const promise::Promise< NodePrxCallbackPromise::PromisegetServerPidPtr > &promise)
        : _promise_getServerPid(promise)
        {}
        
        virtual void callback_getServerPid(const NodePrxCallbackPromise::PromisegetServerPidPtr &ptr)
        {
            _promise_getServerPid.setValue(ptr);
        }
        virtual void callback_getServerPid_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getServerPid_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getServerPid.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< NodePrxCallbackPromise::PromisegetServerPidPtr > _promise_getServerPid;

    public:
        struct PromisegetSettingState: virtual public TC_HandleBase
        {
        public:
            tars::ServerState _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< NodePrxCallbackPromise::PromisegetSettingState > PromisegetSettingStatePtr;

        NodePrxCallbackPromise(const promise::Promise< NodePrxCallbackPromise::PromisegetSettingStatePtr > &promise)
        : _promise_getSettingState(promise)
        {}
        
        virtual void callback_getSettingState(const NodePrxCallbackPromise::PromisegetSettingStatePtr &ptr)
        {
            _promise_getSettingState.setValue(ptr);
        }
        virtual void callback_getSettingState_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getSettingState_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getSettingState.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< NodePrxCallbackPromise::PromisegetSettingStatePtr > _promise_getSettingState;

    public:
        struct PromisegetState: virtual public TC_HandleBase
        {
        public:
            tars::ServerState _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< NodePrxCallbackPromise::PromisegetState > PromisegetStatePtr;

        NodePrxCallbackPromise(const promise::Promise< NodePrxCallbackPromise::PromisegetStatePtr > &promise)
        : _promise_getState(promise)
        {}
        
        virtual void callback_getState(const NodePrxCallbackPromise::PromisegetStatePtr &ptr)
        {
            _promise_getState.setValue(ptr);
        }
        virtual void callback_getState_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getState_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getState.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< NodePrxCallbackPromise::PromisegetStatePtr > _promise_getState;

    public:
        struct PromisegetStateInfo: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            tars::ServerStateInfo info;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< NodePrxCallbackPromise::PromisegetStateInfo > PromisegetStateInfoPtr;

        NodePrxCallbackPromise(const promise::Promise< NodePrxCallbackPromise::PromisegetStateInfoPtr > &promise)
        : _promise_getStateInfo(promise)
        {}
        
        virtual void callback_getStateInfo(const NodePrxCallbackPromise::PromisegetStateInfoPtr &ptr)
        {
            _promise_getStateInfo.setValue(ptr);
        }
        virtual void callback_getStateInfo_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getStateInfo_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getStateInfo.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< NodePrxCallbackPromise::PromisegetStateInfoPtr > _promise_getStateInfo;

    public:
        struct PromisegetUnusedShmKeys: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            vector<tars::Int32> shm_keys;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< NodePrxCallbackPromise::PromisegetUnusedShmKeys > PromisegetUnusedShmKeysPtr;

        NodePrxCallbackPromise(const promise::Promise< NodePrxCallbackPromise::PromisegetUnusedShmKeysPtr > &promise)
        : _promise_getUnusedShmKeys(promise)
        {}
        
        virtual void callback_getUnusedShmKeys(const NodePrxCallbackPromise::PromisegetUnusedShmKeysPtr &ptr)
        {
            _promise_getUnusedShmKeys.setValue(ptr);
        }
        virtual void callback_getUnusedShmKeys_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:getUnusedShmKeys_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_getUnusedShmKeys.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< NodePrxCallbackPromise::PromisegetUnusedShmKeysPtr > _promise_getUnusedShmKeys;

    public:
        struct PromiseloadServer: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< NodePrxCallbackPromise::PromiseloadServer > PromiseloadServerPtr;

        NodePrxCallbackPromise(const promise::Promise< NodePrxCallbackPromise::PromiseloadServerPtr > &promise)
        : _promise_loadServer(promise)
        {}
        
        virtual void callback_loadServer(const NodePrxCallbackPromise::PromiseloadServerPtr &ptr)
        {
            _promise_loadServer.setValue(ptr);
        }
        virtual void callback_loadServer_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:loadServer_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_loadServer.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< NodePrxCallbackPromise::PromiseloadServerPtr > _promise_loadServer;

    public:
        struct PromisenotifyServer: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< NodePrxCallbackPromise::PromisenotifyServer > PromisenotifyServerPtr;

        NodePrxCallbackPromise(const promise::Promise< NodePrxCallbackPromise::PromisenotifyServerPtr > &promise)
        : _promise_notifyServer(promise)
        {}
        
        virtual void callback_notifyServer(const NodePrxCallbackPromise::PromisenotifyServerPtr &ptr)
        {
            _promise_notifyServer.setValue(ptr);
        }
        virtual void callback_notifyServer_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:notifyServer_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_notifyServer.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< NodePrxCallbackPromise::PromisenotifyServerPtr > _promise_notifyServer;

    public:
        struct PromisepatchPro: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< NodePrxCallbackPromise::PromisepatchPro > PromisepatchProPtr;

        NodePrxCallbackPromise(const promise::Promise< NodePrxCallbackPromise::PromisepatchProPtr > &promise)
        : _promise_patchPro(promise)
        {}
        
        virtual void callback_patchPro(const NodePrxCallbackPromise::PromisepatchProPtr &ptr)
        {
            _promise_patchPro.setValue(ptr);
        }
        virtual void callback_patchPro_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:patchPro_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_patchPro.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< NodePrxCallbackPromise::PromisepatchProPtr > _promise_patchPro;

    public:
        struct Promiseshutdown: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< NodePrxCallbackPromise::Promiseshutdown > PromiseshutdownPtr;

        NodePrxCallbackPromise(const promise::Promise< NodePrxCallbackPromise::PromiseshutdownPtr > &promise)
        : _promise_shutdown(promise)
        {}
        
        virtual void callback_shutdown(const NodePrxCallbackPromise::PromiseshutdownPtr &ptr)
        {
            _promise_shutdown.setValue(ptr);
        }
        virtual void callback_shutdown_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:shutdown_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_shutdown.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< NodePrxCallbackPromise::PromiseshutdownPtr > _promise_shutdown;

    public:
        struct PromisestartServer: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< NodePrxCallbackPromise::PromisestartServer > PromisestartServerPtr;

        NodePrxCallbackPromise(const promise::Promise< NodePrxCallbackPromise::PromisestartServerPtr > &promise)
        : _promise_startServer(promise)
        {}
        
        virtual void callback_startServer(const NodePrxCallbackPromise::PromisestartServerPtr &ptr)
        {
            _promise_startServer.setValue(ptr);
        }
        virtual void callback_startServer_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:startServer_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_startServer.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< NodePrxCallbackPromise::PromisestartServerPtr > _promise_startServer;

    public:
        struct PromisestopAllServers: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< NodePrxCallbackPromise::PromisestopAllServers > PromisestopAllServersPtr;

        NodePrxCallbackPromise(const promise::Promise< NodePrxCallbackPromise::PromisestopAllServersPtr > &promise)
        : _promise_stopAllServers(promise)
        {}
        
        virtual void callback_stopAllServers(const NodePrxCallbackPromise::PromisestopAllServersPtr &ptr)
        {
            _promise_stopAllServers.setValue(ptr);
        }
        virtual void callback_stopAllServers_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:stopAllServers_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_stopAllServers.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< NodePrxCallbackPromise::PromisestopAllServersPtr > _promise_stopAllServers;

    public:
        struct PromisestopServer: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< NodePrxCallbackPromise::PromisestopServer > PromisestopServerPtr;

        NodePrxCallbackPromise(const promise::Promise< NodePrxCallbackPromise::PromisestopServerPtr > &promise)
        : _promise_stopServer(promise)
        {}
        
        virtual void callback_stopServer(const NodePrxCallbackPromise::PromisestopServerPtr &ptr)
        {
            _promise_stopServer.setValue(ptr);
        }
        virtual void callback_stopServer_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:stopServer_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_stopServer.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< NodePrxCallbackPromise::PromisestopServerPtr > _promise_stopServer;

    public:
        struct PromisesynState: virtual public TC_HandleBase
        {
        public:
            tars::Int32 _ret;
            std::string result;
            map<std::string, std::string> _mRspContext;
        };
        
        typedef tars::TC_AutoPtr< NodePrxCallbackPromise::PromisesynState > PromisesynStatePtr;

        NodePrxCallbackPromise(const promise::Promise< NodePrxCallbackPromise::PromisesynStatePtr > &promise)
        : _promise_synState(promise)
        {}
        
        virtual void callback_synState(const NodePrxCallbackPromise::PromisesynStatePtr &ptr)
        {
            _promise_synState.setValue(ptr);
        }
        virtual void callback_synState_exception(tars::Int32 ret)
        {
            std::string str("");
            str += "Function:synState_exception|Ret:";
            str += TC_Common::tostr(ret);
            _promise_synState.setException(promise::copyException(str, ret));
        }

    protected:
        promise::Promise< NodePrxCallbackPromise::PromisesynStatePtr > _promise_synState;

    public:
        virtual int onDispatch(tars::ReqMessagePtr msg)
        {
            static ::std::string __Node_all[]=
            {
                "addFile",
                "delCache",
                "destroyServer",
                "getLoad",
                "getName",
                "getPatchPercent",
                "getServerPid",
                "getSettingState",
                "getState",
                "getStateInfo",
                "getUnusedShmKeys",
                "loadServer",
                "notifyServer",
                "patchPro",
                "shutdown",
                "startServer",
                "stopAllServers",
                "stopServer",
                "synState"
            };

            pair<string*, string*> r = equal_range(__Node_all, __Node_all+19, string(msg->request.sFuncName));
            if(r.first == r.second) return tars::TARSSERVERNOFUNCERR;
            switch(r.first - __Node_all)
            {
                case 0:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_addFile_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    NodePrxCallbackPromise::PromiseaddFilePtr ptr = new NodePrxCallbackPromise::PromiseaddFile();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_addFile_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_addFile_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_addFile(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_delCache_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    NodePrxCallbackPromise::PromisedelCachePtr ptr = new NodePrxCallbackPromise::PromisedelCache();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_delCache_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_delCache_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_delCache(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_destroyServer_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    NodePrxCallbackPromise::PromisedestroyServerPtr ptr = new NodePrxCallbackPromise::PromisedestroyServer();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 3, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_destroyServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_destroyServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_destroyServer(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getLoad_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    NodePrxCallbackPromise::PromisegetLoadPtr ptr = new NodePrxCallbackPromise::PromisegetLoad();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getLoad_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getLoad_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_getLoad(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 4:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getName_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    NodePrxCallbackPromise::PromisegetNamePtr ptr = new NodePrxCallbackPromise::PromisegetName();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getName_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getName_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_getName(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 5:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getPatchPercent_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    NodePrxCallbackPromise::PromisegetPatchPercentPtr ptr = new NodePrxCallbackPromise::PromisegetPatchPercent();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->tPatchInfo, 3, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getPatchPercent_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getPatchPercent_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_getPatchPercent(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 6:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getServerPid_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    NodePrxCallbackPromise::PromisegetServerPidPtr ptr = new NodePrxCallbackPromise::PromisegetServerPid();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 3, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getServerPid_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getServerPid_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_getServerPid(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 7:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getSettingState_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    NodePrxCallbackPromise::PromisegetSettingStatePtr ptr = new NodePrxCallbackPromise::PromisegetSettingState();

                    try
                    {
                        ptr->_ret  = tars::Inactive;;
                        tars::Int32 eTemp0 = tars::Inactive;
                        _is.read(eTemp0, 0, true);
                        ptr->_ret = (tars::ServerState)eTemp0;

                        _is.read(ptr->result, 3, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getSettingState_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getSettingState_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_getSettingState(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 8:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getState_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    NodePrxCallbackPromise::PromisegetStatePtr ptr = new NodePrxCallbackPromise::PromisegetState();

                    try
                    {
                        ptr->_ret  = tars::Inactive;;
                        tars::Int32 eTemp0 = tars::Inactive;
                        _is.read(eTemp0, 0, true);
                        ptr->_ret = (tars::ServerState)eTemp0;

                        _is.read(ptr->result, 3, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getState_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getState_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_getState(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 9:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getStateInfo_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    NodePrxCallbackPromise::PromisegetStateInfoPtr ptr = new NodePrxCallbackPromise::PromisegetStateInfo();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->info, 3, true);
                        _is.read(ptr->result, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getStateInfo_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getStateInfo_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_getStateInfo(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 10:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getUnusedShmKeys_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    NodePrxCallbackPromise::PromisegetUnusedShmKeysPtr ptr = new NodePrxCallbackPromise::PromisegetUnusedShmKeys();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->shm_keys, 2, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_getUnusedShmKeys_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getUnusedShmKeys_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_getUnusedShmKeys(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 11:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_loadServer_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    NodePrxCallbackPromise::PromiseloadServerPtr ptr = new NodePrxCallbackPromise::PromiseloadServer();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 3, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_loadServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_loadServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_loadServer(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 12:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_notifyServer_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    NodePrxCallbackPromise::PromisenotifyServerPtr ptr = new NodePrxCallbackPromise::PromisenotifyServer();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 4, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_notifyServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_notifyServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_notifyServer(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 13:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_patchPro_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    NodePrxCallbackPromise::PromisepatchProPtr ptr = new NodePrxCallbackPromise::PromisepatchPro();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 2, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_patchPro_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_patchPro_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_patchPro(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 14:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_shutdown_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    NodePrxCallbackPromise::PromiseshutdownPtr ptr = new NodePrxCallbackPromise::Promiseshutdown();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 1, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_shutdown_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_shutdown_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_shutdown(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 15:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_startServer_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    NodePrxCallbackPromise::PromisestartServerPtr ptr = new NodePrxCallbackPromise::PromisestartServer();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 3, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_startServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_startServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_startServer(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 16:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_stopAllServers_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    NodePrxCallbackPromise::PromisestopAllServersPtr ptr = new NodePrxCallbackPromise::PromisestopAllServers();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 1, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_stopAllServers_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_stopAllServers_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_stopAllServers(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 17:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_stopServer_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    NodePrxCallbackPromise::PromisestopServerPtr ptr = new NodePrxCallbackPromise::PromisestopServer();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 3, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_stopServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_stopServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_stopServer(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
                case 18:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_synState_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);

                    NodePrxCallbackPromise::PromisesynStatePtr ptr = new NodePrxCallbackPromise::PromisesynState();

                    try
                    {
                        _is.read(ptr->_ret, 0, true);

                        _is.read(ptr->result, 3, true);
                    }
                    catch(std::exception &ex)
                    {
                        callback_synState_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_synState_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    ptr->_mRspContext = msg->response.context;

                    callback_synState(ptr);

                    return tars::TARSSERVERSUCCESS;

                }
            }
            return tars::TARSSERVERNOFUNCERR;
        }

    };
    typedef tars::TC_AutoPtr<NodePrxCallbackPromise> NodePrxCallbackPromisePtr;

    /* callback of coroutine async proxy for client */
    class NodeCoroPrxCallback: public NodePrxCallback
    {
    public:
        virtual ~NodeCoroPrxCallback(){}
    public:
        virtual const map<std::string, std::string> & getResponseContext() const { return _mRspContext; }

        virtual void setResponseContext(const map<std::string, std::string> &mContext) { _mRspContext = mContext; }

    public:
        int onDispatch(tars::ReqMessagePtr msg)
        {
            static ::std::string __Node_all[]=
            {
                "addFile",
                "delCache",
                "destroyServer",
                "getLoad",
                "getName",
                "getPatchPercent",
                "getServerPid",
                "getSettingState",
                "getState",
                "getStateInfo",
                "getUnusedShmKeys",
                "loadServer",
                "notifyServer",
                "patchPro",
                "shutdown",
                "startServer",
                "stopAllServers",
                "stopServer",
                "synState"
            };

            pair<string*, string*> r = equal_range(__Node_all, __Node_all+19, string(msg->request.sFuncName));
            if(r.first == r.second) return tars::TARSSERVERNOFUNCERR;
            switch(r.first - __Node_all)
            {
                case 0:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_addFile_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 4, true);
                        setResponseContext(msg->response.context);

                        callback_addFile(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_addFile_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_addFile_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_delCache_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 4, true);
                        setResponseContext(msg->response.context);

                        callback_delCache(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_delCache_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_delCache_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_destroyServer_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 3, true);
                        setResponseContext(msg->response.context);

                        callback_destroyServer(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_destroyServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_destroyServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getLoad_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::LoadInfo _ret;
                        _is.read(_ret, 0, true);

                        setResponseContext(msg->response.context);

                        callback_getLoad(_ret);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getLoad_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getLoad_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 4:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getName_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        std::string _ret;
                        _is.read(_ret, 0, true);

                        setResponseContext(msg->response.context);

                        callback_getName(_ret);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getName_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getName_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 5:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getPatchPercent_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        tars::PatchInfo tPatchInfo;
                        _is.read(tPatchInfo, 3, true);
                        setResponseContext(msg->response.context);

                        callback_getPatchPercent(_ret, tPatchInfo);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getPatchPercent_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getPatchPercent_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 6:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getServerPid_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 3, true);
                        setResponseContext(msg->response.context);

                        callback_getServerPid(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getServerPid_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getServerPid_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 7:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getSettingState_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::ServerState _ret = tars::Inactive;;
                        tars::Int32 eTemp0 = tars::Inactive;
                        _is.read(eTemp0, 0, true);
                        _ret = (tars::ServerState)eTemp0;

                        std::string result;
                        _is.read(result, 3, true);
                        setResponseContext(msg->response.context);

                        callback_getSettingState(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getSettingState_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getSettingState_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 8:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getState_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::ServerState _ret = tars::Inactive;;
                        tars::Int32 eTemp0 = tars::Inactive;
                        _is.read(eTemp0, 0, true);
                        _ret = (tars::ServerState)eTemp0;

                        std::string result;
                        _is.read(result, 3, true);
                        setResponseContext(msg->response.context);

                        callback_getState(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getState_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getState_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 9:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getStateInfo_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        tars::ServerStateInfo info;
                        _is.read(info, 3, true);
                        std::string result;
                        _is.read(result, 4, true);
                        setResponseContext(msg->response.context);

                        callback_getStateInfo(_ret, info, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getStateInfo_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getStateInfo_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 10:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_getUnusedShmKeys_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        vector<tars::Int32> shm_keys;
                        _is.read(shm_keys, 2, true);
                        setResponseContext(msg->response.context);

                        callback_getUnusedShmKeys(_ret, shm_keys);

                    }
                    catch(std::exception &ex)
                    {
                        callback_getUnusedShmKeys_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_getUnusedShmKeys_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 11:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_loadServer_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 3, true);
                        setResponseContext(msg->response.context);

                        callback_loadServer(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_loadServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_loadServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 12:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_notifyServer_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 4, true);
                        setResponseContext(msg->response.context);

                        callback_notifyServer(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_notifyServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_notifyServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 13:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_patchPro_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 2, true);
                        setResponseContext(msg->response.context);

                        callback_patchPro(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_patchPro_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_patchPro_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 14:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_shutdown_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 1, true);
                        setResponseContext(msg->response.context);

                        callback_shutdown(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_shutdown_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_shutdown_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 15:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_startServer_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 3, true);
                        setResponseContext(msg->response.context);

                        callback_startServer(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_startServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_startServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 16:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_stopAllServers_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 1, true);
                        setResponseContext(msg->response.context);

                        callback_stopAllServers(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_stopAllServers_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_stopAllServers_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 17:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_stopServer_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 3, true);
                        setResponseContext(msg->response.context);

                        callback_stopServer(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_stopServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_stopServer_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
                case 18:
                {
                    if (msg->response.iRet != tars::TARSSERVERSUCCESS)
                    {
                        callback_synState_exception(msg->response.iRet);

                        return msg->response.iRet;
                    }
                    tars::TarsInputStream<tars::BufferReader> _is;

                    _is.setBuffer(msg->response.sBuffer);
                    try
                    {
                        tars::Int32 _ret;
                        _is.read(_ret, 0, true);

                        std::string result;
                        _is.read(result, 3, true);
                        setResponseContext(msg->response.context);

                        callback_synState(_ret, result);

                    }
                    catch(std::exception &ex)
                    {
                        callback_synState_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }
                    catch(...)
                    {
                        callback_synState_exception(tars::TARSCLIENTDECODEERR);

                        return tars::TARSCLIENTDECODEERR;
                    }

                    return tars::TARSSERVERSUCCESS;

                }
            }
            return tars::TARSSERVERNOFUNCERR;
        }

    protected:
        map<std::string, std::string> _mRspContext;
    };
    typedef tars::TC_AutoPtr<NodeCoroPrxCallback> NodeCoroPrxCallbackPtr;

    /* proxy for client */
    class NodeProxy : public tars::ServantProxy
    {
    public:
        typedef map<string, string> TARS_CONTEXT;
        tars::Int32 addFile(const std::string & application,const std::string & serverName,const std::string & file,std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(file, 3);
            _os.write(result, 4);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"addFile", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 4, true);
            return _ret;
        }

        void async_addFile(NodePrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &file,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(file, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"addFile", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< NodePrxCallbackPromise::PromiseaddFilePtr > promise_async_addFile(const std::string &application,const std::string &serverName,const std::string &file,const map<string, string>& context)
        {
            promise::Promise< NodePrxCallbackPromise::PromiseaddFilePtr > promise;
            NodePrxCallbackPromisePtr callback = new NodePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(file, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"addFile", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_addFile(NodeCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &file,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(file, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"addFile", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::Int32 delCache(const std::string & sFullCacheName,const std::string & sBackupPath,const std::string & sKey,std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(sFullCacheName, 1);
            _os.write(sBackupPath, 2);
            _os.write(sKey, 3);
            _os.write(result, 4);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"delCache", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 4, true);
            return _ret;
        }

        void async_delCache(NodePrxCallbackPtr callback,const std::string &sFullCacheName,const std::string &sBackupPath,const std::string &sKey,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(sFullCacheName, 1);
            _os.write(sBackupPath, 2);
            _os.write(sKey, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"delCache", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< NodePrxCallbackPromise::PromisedelCachePtr > promise_async_delCache(const std::string &sFullCacheName,const std::string &sBackupPath,const std::string &sKey,const map<string, string>& context)
        {
            promise::Promise< NodePrxCallbackPromise::PromisedelCachePtr > promise;
            NodePrxCallbackPromisePtr callback = new NodePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(sFullCacheName, 1);
            _os.write(sBackupPath, 2);
            _os.write(sKey, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"delCache", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_delCache(NodeCoroPrxCallbackPtr callback,const std::string &sFullCacheName,const std::string &sBackupPath,const std::string &sKey,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(sFullCacheName, 1);
            _os.write(sBackupPath, 2);
            _os.write(sKey, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"delCache", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::Int32 destroyServer(const std::string & application,const std::string & serverName,std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(result, 3);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"destroyServer", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 3, true);
            return _ret;
        }

        void async_destroyServer(NodePrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"destroyServer", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< NodePrxCallbackPromise::PromisedestroyServerPtr > promise_async_destroyServer(const std::string &application,const std::string &serverName,const map<string, string>& context)
        {
            promise::Promise< NodePrxCallbackPromise::PromisedestroyServerPtr > promise;
            NodePrxCallbackPromisePtr callback = new NodePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"destroyServer", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_destroyServer(NodeCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"destroyServer", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::LoadInfo getLoad(const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"getLoad", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::LoadInfo _ret;
            _is.read(_ret, 0, true);
            return _ret;
        }

        void async_getLoad(NodePrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getLoad", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< NodePrxCallbackPromise::PromisegetLoadPtr > promise_async_getLoad(const map<string, string>& context)
        {
            promise::Promise< NodePrxCallbackPromise::PromisegetLoadPtr > promise;
            NodePrxCallbackPromisePtr callback = new NodePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getLoad", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getLoad(NodeCoroPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getLoad", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        std::string getName(const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"getName", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            std::string _ret;
            _is.read(_ret, 0, true);
            return _ret;
        }

        void async_getName(NodePrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getName", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< NodePrxCallbackPromise::PromisegetNamePtr > promise_async_getName(const map<string, string>& context)
        {
            promise::Promise< NodePrxCallbackPromise::PromisegetNamePtr > promise;
            NodePrxCallbackPromisePtr callback = new NodePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getName", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getName(NodeCoroPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getName", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::Int32 getPatchPercent(const std::string & application,const std::string & serverName,tars::PatchInfo &tPatchInfo,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(tPatchInfo, 3);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"getPatchPercent", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(tPatchInfo, 3, true);
            return _ret;
        }

        void async_getPatchPercent(NodePrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getPatchPercent", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< NodePrxCallbackPromise::PromisegetPatchPercentPtr > promise_async_getPatchPercent(const std::string &application,const std::string &serverName,const map<string, string>& context)
        {
            promise::Promise< NodePrxCallbackPromise::PromisegetPatchPercentPtr > promise;
            NodePrxCallbackPromisePtr callback = new NodePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getPatchPercent", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getPatchPercent(NodeCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getPatchPercent", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::Int32 getServerPid(const std::string & application,const std::string & serverName,std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(result, 3);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"getServerPid", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 3, true);
            return _ret;
        }

        void async_getServerPid(NodePrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getServerPid", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< NodePrxCallbackPromise::PromisegetServerPidPtr > promise_async_getServerPid(const std::string &application,const std::string &serverName,const map<string, string>& context)
        {
            promise::Promise< NodePrxCallbackPromise::PromisegetServerPidPtr > promise;
            NodePrxCallbackPromisePtr callback = new NodePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getServerPid", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getServerPid(NodeCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getServerPid", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::ServerState getSettingState(const std::string & application,const std::string & serverName,std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(result, 3);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"getSettingState", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::ServerState _ret = tars::Inactive;;
            tars::Int32 eTemp0 = tars::Inactive;
            _is.read(eTemp0, 0, true);
            _ret = (tars::ServerState)eTemp0;
            _is.read(result, 3, true);
            return _ret;
        }

        void async_getSettingState(NodePrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getSettingState", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< NodePrxCallbackPromise::PromisegetSettingStatePtr > promise_async_getSettingState(const std::string &application,const std::string &serverName,const map<string, string>& context)
        {
            promise::Promise< NodePrxCallbackPromise::PromisegetSettingStatePtr > promise;
            NodePrxCallbackPromisePtr callback = new NodePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getSettingState", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getSettingState(NodeCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getSettingState", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::ServerState getState(const std::string & application,const std::string & serverName,std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(result, 3);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"getState", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::ServerState _ret = tars::Inactive;;
            tars::Int32 eTemp0 = tars::Inactive;
            _is.read(eTemp0, 0, true);
            _ret = (tars::ServerState)eTemp0;
            _is.read(result, 3, true);
            return _ret;
        }

        void async_getState(NodePrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getState", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< NodePrxCallbackPromise::PromisegetStatePtr > promise_async_getState(const std::string &application,const std::string &serverName,const map<string, string>& context)
        {
            promise::Promise< NodePrxCallbackPromise::PromisegetStatePtr > promise;
            NodePrxCallbackPromisePtr callback = new NodePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getState", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getState(NodeCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getState", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::Int32 getStateInfo(const std::string & application,const std::string & serverName,tars::ServerStateInfo &info,std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(info, 3);
            _os.write(result, 4);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"getStateInfo", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(info, 3, true);
            _is.read(result, 4, true);
            return _ret;
        }

        void async_getStateInfo(NodePrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getStateInfo", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< NodePrxCallbackPromise::PromisegetStateInfoPtr > promise_async_getStateInfo(const std::string &application,const std::string &serverName,const map<string, string>& context)
        {
            promise::Promise< NodePrxCallbackPromise::PromisegetStateInfoPtr > promise;
            NodePrxCallbackPromisePtr callback = new NodePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getStateInfo", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getStateInfo(NodeCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getStateInfo", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::Int32 getUnusedShmKeys(tars::Int32 count,vector<tars::Int32> &shm_keys,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(count, 1);
            _os.write(shm_keys, 2);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"getUnusedShmKeys", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(shm_keys, 2, true);
            return _ret;
        }

        void async_getUnusedShmKeys(NodePrxCallbackPtr callback,tars::Int32 count,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(count, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getUnusedShmKeys", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< NodePrxCallbackPromise::PromisegetUnusedShmKeysPtr > promise_async_getUnusedShmKeys(tars::Int32 count,const map<string, string>& context)
        {
            promise::Promise< NodePrxCallbackPromise::PromisegetUnusedShmKeysPtr > promise;
            NodePrxCallbackPromisePtr callback = new NodePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(count, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getUnusedShmKeys", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_getUnusedShmKeys(NodeCoroPrxCallbackPtr callback,tars::Int32 count,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(count, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"getUnusedShmKeys", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::Int32 loadServer(const std::string & application,const std::string & serverName,std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(result, 3);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"loadServer", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 3, true);
            return _ret;
        }

        void async_loadServer(NodePrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"loadServer", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< NodePrxCallbackPromise::PromiseloadServerPtr > promise_async_loadServer(const std::string &application,const std::string &serverName,const map<string, string>& context)
        {
            promise::Promise< NodePrxCallbackPromise::PromiseloadServerPtr > promise;
            NodePrxCallbackPromisePtr callback = new NodePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"loadServer", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_loadServer(NodeCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"loadServer", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::Int32 notifyServer(const std::string & application,const std::string & serverName,const std::string & command,std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(command, 3);
            _os.write(result, 4);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"notifyServer", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 4, true);
            return _ret;
        }

        void async_notifyServer(NodePrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &command,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(command, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"notifyServer", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< NodePrxCallbackPromise::PromisenotifyServerPtr > promise_async_notifyServer(const std::string &application,const std::string &serverName,const std::string &command,const map<string, string>& context)
        {
            promise::Promise< NodePrxCallbackPromise::PromisenotifyServerPtr > promise;
            NodePrxCallbackPromisePtr callback = new NodePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(command, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"notifyServer", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_notifyServer(NodeCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const std::string &command,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(command, 3);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"notifyServer", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::Int32 patchPro(const tars::PatchRequest & req,std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(req, 1);
            _os.write(result, 2);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"patchPro", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 2, true);
            return _ret;
        }

        void async_patchPro(NodePrxCallbackPtr callback,const tars::PatchRequest &req,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"patchPro", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< NodePrxCallbackPromise::PromisepatchProPtr > promise_async_patchPro(const tars::PatchRequest &req,const map<string, string>& context)
        {
            promise::Promise< NodePrxCallbackPromise::PromisepatchProPtr > promise;
            NodePrxCallbackPromisePtr callback = new NodePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"patchPro", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_patchPro(NodeCoroPrxCallbackPtr callback,const tars::PatchRequest &req,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(req, 1);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"patchPro", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::Int32 shutdown(std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(result, 1);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"shutdown", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 1, true);
            return _ret;
        }

        void async_shutdown(NodePrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"shutdown", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< NodePrxCallbackPromise::PromiseshutdownPtr > promise_async_shutdown(const map<string, string>& context)
        {
            promise::Promise< NodePrxCallbackPromise::PromiseshutdownPtr > promise;
            NodePrxCallbackPromisePtr callback = new NodePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"shutdown", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_shutdown(NodeCoroPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"shutdown", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::Int32 startServer(const std::string & application,const std::string & serverName,std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(result, 3);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"startServer", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 3, true);
            return _ret;
        }

        void async_startServer(NodePrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"startServer", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< NodePrxCallbackPromise::PromisestartServerPtr > promise_async_startServer(const std::string &application,const std::string &serverName,const map<string, string>& context)
        {
            promise::Promise< NodePrxCallbackPromise::PromisestartServerPtr > promise;
            NodePrxCallbackPromisePtr callback = new NodePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"startServer", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_startServer(NodeCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"startServer", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::Int32 stopAllServers(std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(result, 1);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"stopAllServers", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 1, true);
            return _ret;
        }

        void async_stopAllServers(NodePrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"stopAllServers", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< NodePrxCallbackPromise::PromisestopAllServersPtr > promise_async_stopAllServers(const map<string, string>& context)
        {
            promise::Promise< NodePrxCallbackPromise::PromisestopAllServersPtr > promise;
            NodePrxCallbackPromisePtr callback = new NodePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"stopAllServers", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_stopAllServers(NodeCoroPrxCallbackPtr callback,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"stopAllServers", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::Int32 stopServer(const std::string & application,const std::string & serverName,std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(result, 3);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"stopServer", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 3, true);
            return _ret;
        }

        void async_stopServer(NodePrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"stopServer", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< NodePrxCallbackPromise::PromisestopServerPtr > promise_async_stopServer(const std::string &application,const std::string &serverName,const map<string, string>& context)
        {
            promise::Promise< NodePrxCallbackPromise::PromisestopServerPtr > promise;
            NodePrxCallbackPromisePtr callback = new NodePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"stopServer", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_stopServer(NodeCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"stopServer", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        tars::Int32 synState(const std::string & application,const std::string & serverName,std::string &result,const map<string, string> &context = TARS_CONTEXT(),map<string, string> * pResponseContext = NULL)
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            _os.write(result, 3);
            tars::ResponsePacket rep;
            std::map<string, string> _mStatus;
            tars_invoke(tars::TARSNORMAL,"synState", _os.getByteBuffer(), context, _mStatus, rep);
            if(pResponseContext)
            {
                *pResponseContext = rep.context;
            }

            tars::TarsInputStream<tars::BufferReader> _is;
            _is.setBuffer(rep.sBuffer);
            tars::Int32 _ret;
            _is.read(_ret, 0, true);
            _is.read(result, 3, true);
            return _ret;
        }

        void async_synState(NodePrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"synState", _os.getByteBuffer(), context, _mStatus, callback);
        }
        
        promise::Future< NodePrxCallbackPromise::PromisesynStatePtr > promise_async_synState(const std::string &application,const std::string &serverName,const map<string, string>& context)
        {
            promise::Promise< NodePrxCallbackPromise::PromisesynStatePtr > promise;
            NodePrxCallbackPromisePtr callback = new NodePrxCallbackPromise(promise);

            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"synState", _os.getByteBuffer(), context, _mStatus, callback);

            return promise.getFuture();
        }

        void coro_synState(NodeCoroPrxCallbackPtr callback,const std::string &application,const std::string &serverName,const map<string, string>& context = TARS_CONTEXT())
        {
            tars::TarsOutputStream<tars::BufferWriter> _os;
            _os.write(application, 1);
            _os.write(serverName, 2);
            std::map<string, string> _mStatus;
            tars_invoke_async(tars::TARSNORMAL,"synState", _os.getByteBuffer(), context, _mStatus, callback, true);
        }

        NodeProxy* tars_hash(int64_t key)
        {
            return (NodeProxy*)ServantProxy::tars_hash(key);
        }

        NodeProxy* tars_consistent_hash(int64_t key)
        {
            return (NodeProxy*)ServantProxy::tars_consistent_hash(key);
        }

        NodeProxy* tars_set_timeout(int msecond)
        {
            return (NodeProxy*)ServantProxy::tars_set_timeout(msecond);
        }

    };
    typedef tars::TC_AutoPtr<NodeProxy> NodePrx;

    /* servant for server */
    class Node : public tars::Servant
    {
    public:
        virtual ~Node(){}
        virtual tars::Int32 addFile(const std::string & application,const std::string & serverName,const std::string & file,std::string &result,tars::TarsCurrentPtr current) = 0;
        static void async_response_addFile(tars::TarsCurrentPtr current, tars::Int32 _ret, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(result, 4);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 delCache(const std::string & sFullCacheName,const std::string & sBackupPath,const std::string & sKey,std::string &result,tars::TarsCurrentPtr current) = 0;
        static void async_response_delCache(tars::TarsCurrentPtr current, tars::Int32 _ret, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(result, 4);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 destroyServer(const std::string & application,const std::string & serverName,std::string &result,tars::TarsCurrentPtr current) = 0;
        static void async_response_destroyServer(tars::TarsCurrentPtr current, tars::Int32 _ret, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(result, 3);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::LoadInfo getLoad(tars::TarsCurrentPtr current) = 0;
        static void async_response_getLoad(tars::TarsCurrentPtr current, const tars::LoadInfo &_ret)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual std::string getName(tars::TarsCurrentPtr current) = 0;
        static void async_response_getName(tars::TarsCurrentPtr current, const std::string &_ret)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 getPatchPercent(const std::string & application,const std::string & serverName,tars::PatchInfo &tPatchInfo,tars::TarsCurrentPtr current) = 0;
        static void async_response_getPatchPercent(tars::TarsCurrentPtr current, tars::Int32 _ret, const tars::PatchInfo &tPatchInfo)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("tPatchInfo", tPatchInfo);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(tPatchInfo, 3);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 getServerPid(const std::string & application,const std::string & serverName,std::string &result,tars::TarsCurrentPtr current) = 0;
        static void async_response_getServerPid(tars::TarsCurrentPtr current, tars::Int32 _ret, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(result, 3);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::ServerState getSettingState(const std::string & application,const std::string & serverName,std::string &result,tars::TarsCurrentPtr current) = 0;
        static void async_response_getSettingState(tars::TarsCurrentPtr current, tars::ServerState _ret, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", (tars::Int32)_ret);
                tarsAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write((tars::Int32)_ret, 0);

                _os.write(result, 3);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::ServerState getState(const std::string & application,const std::string & serverName,std::string &result,tars::TarsCurrentPtr current) = 0;
        static void async_response_getState(tars::TarsCurrentPtr current, tars::ServerState _ret, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", (tars::Int32)_ret);
                tarsAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write((tars::Int32)_ret, 0);

                _os.write(result, 3);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 getStateInfo(const std::string & application,const std::string & serverName,tars::ServerStateInfo &info,std::string &result,tars::TarsCurrentPtr current) = 0;
        static void async_response_getStateInfo(tars::TarsCurrentPtr current, tars::Int32 _ret, const tars::ServerStateInfo &info, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("info", info);
                tarsAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(info, 3);

                _os.write(result, 4);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 getUnusedShmKeys(tars::Int32 count,vector<tars::Int32> &shm_keys,tars::TarsCurrentPtr current) = 0;
        static void async_response_getUnusedShmKeys(tars::TarsCurrentPtr current, tars::Int32 _ret, const vector<tars::Int32> &shm_keys)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("shm_keys", shm_keys);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(shm_keys, 2);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 loadServer(const std::string & application,const std::string & serverName,std::string &result,tars::TarsCurrentPtr current) = 0;
        static void async_response_loadServer(tars::TarsCurrentPtr current, tars::Int32 _ret, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(result, 3);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 notifyServer(const std::string & application,const std::string & serverName,const std::string & command,std::string &result,tars::TarsCurrentPtr current) = 0;
        static void async_response_notifyServer(tars::TarsCurrentPtr current, tars::Int32 _ret, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(result, 4);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 patchPro(const tars::PatchRequest & req,std::string &result,tars::TarsCurrentPtr current) = 0;
        static void async_response_patchPro(tars::TarsCurrentPtr current, tars::Int32 _ret, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(result, 2);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 shutdown(std::string &result,tars::TarsCurrentPtr current) = 0;
        static void async_response_shutdown(tars::TarsCurrentPtr current, tars::Int32 _ret, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(result, 1);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 startServer(const std::string & application,const std::string & serverName,std::string &result,tars::TarsCurrentPtr current) = 0;
        static void async_response_startServer(tars::TarsCurrentPtr current, tars::Int32 _ret, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(result, 3);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 stopAllServers(std::string &result,tars::TarsCurrentPtr current) = 0;
        static void async_response_stopAllServers(tars::TarsCurrentPtr current, tars::Int32 _ret, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(result, 1);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 stopServer(const std::string & application,const std::string & serverName,std::string &result,tars::TarsCurrentPtr current) = 0;
        static void async_response_stopServer(tars::TarsCurrentPtr current, tars::Int32 _ret, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(result, 3);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

        virtual tars::Int32 synState(const std::string & application,const std::string & serverName,std::string &result,tars::TarsCurrentPtr current) = 0;
        static void async_response_synState(tars::TarsCurrentPtr current, tars::Int32 _ret, const std::string &result)
        {
            if (current->getRequestVersion() == TUPVERSION )
            {
                UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                tarsAttr.setVersion(current->getRequestVersion());
                tarsAttr.put("", _ret);
                tarsAttr.put("result", result);

                vector<char> sTupResponseBuffer;
                tarsAttr.encode(sTupResponseBuffer);
                current->sendResponse(tars::TARSSERVERSUCCESS, sTupResponseBuffer);
            }
            else
            {
                tars::TarsOutputStream<tars::BufferWriter> _os;
                _os.write(_ret, 0);

                _os.write(result, 3);

                current->sendResponse(tars::TARSSERVERSUCCESS, _os.getByteBuffer());
            }
        }

    public:
        int onDispatch(tars::TarsCurrentPtr _current, vector<char> &_sResponseBuffer)
        {
            static ::std::string __tars__Node_all[]=
            {
                "addFile",
                "delCache",
                "destroyServer",
                "getLoad",
                "getName",
                "getPatchPercent",
                "getServerPid",
                "getSettingState",
                "getState",
                "getStateInfo",
                "getUnusedShmKeys",
                "loadServer",
                "notifyServer",
                "patchPro",
                "shutdown",
                "startServer",
                "stopAllServers",
                "stopServer",
                "synState"
            };

            pair<string*, string*> r = equal_range(__tars__Node_all, __tars__Node_all+19, _current->getFuncName());
            if(r.first == r.second) return tars::TARSSERVERNOFUNCERR;
            switch(r.first - __tars__Node_all)
            {
                case 0:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string file;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("application", application);
                        tarsAttr.get("serverName", serverName);
                        tarsAttr.get("file", file);
                        tarsAttr.getByDefault("result", result, result);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(file, 3, true);
                        _is.read(result, 4, false);
                    }
                    tars::Int32 _ret = addFile(application,serverName,file,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("result", result);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 4);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 1:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string sFullCacheName;
                    std::string sBackupPath;
                    std::string sKey;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("sFullCacheName", sFullCacheName);
                        tarsAttr.get("sBackupPath", sBackupPath);
                        tarsAttr.get("sKey", sKey);
                        tarsAttr.getByDefault("result", result, result);
                    }
                    else
                    {
                        _is.read(sFullCacheName, 1, true);
                        _is.read(sBackupPath, 2, true);
                        _is.read(sKey, 3, true);
                        _is.read(result, 4, false);
                    }
                    tars::Int32 _ret = delCache(sFullCacheName,sBackupPath,sKey,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("result", result);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 4);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 2:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("application", application);
                        tarsAttr.get("serverName", serverName);
                        tarsAttr.getByDefault("result", result, result);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(result, 3, false);
                    }
                    tars::Int32 _ret = destroyServer(application,serverName,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("result", result);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 3);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 3:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                    }
                    else
                    {
                    }
                    tars::LoadInfo _ret = getLoad(_current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 4:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                    }
                    else
                    {
                    }
                    std::string _ret = getName(_current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 5:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    tars::PatchInfo tPatchInfo;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("application", application);
                        tarsAttr.get("serverName", serverName);
                        tarsAttr.getByDefault("tPatchInfo", tPatchInfo, tPatchInfo);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(tPatchInfo, 3, false);
                    }
                    tars::Int32 _ret = getPatchPercent(application,serverName,tPatchInfo, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("tPatchInfo", tPatchInfo);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(tPatchInfo, 3);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 6:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("application", application);
                        tarsAttr.get("serverName", serverName);
                        tarsAttr.getByDefault("result", result, result);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(result, 3, false);
                    }
                    tars::Int32 _ret = getServerPid(application,serverName,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("result", result);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 3);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 7:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("application", application);
                        tarsAttr.get("serverName", serverName);
                        tarsAttr.getByDefault("result", result, result);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(result, 3, false);
                    }
                    tars::ServerState _ret = getSettingState(application,serverName,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", (tars::Int32)_ret);
                            tarsAttr.put("result", result);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write((tars::Int32)_ret, 0);
                            _os.write(result, 3);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 8:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("application", application);
                        tarsAttr.get("serverName", serverName);
                        tarsAttr.getByDefault("result", result, result);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(result, 3, false);
                    }
                    tars::ServerState _ret = getState(application,serverName,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", (tars::Int32)_ret);
                            tarsAttr.put("result", result);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write((tars::Int32)_ret, 0);
                            _os.write(result, 3);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 9:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    tars::ServerStateInfo info;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("application", application);
                        tarsAttr.get("serverName", serverName);
                        tarsAttr.getByDefault("info", info, info);
                        tarsAttr.getByDefault("result", result, result);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(info, 3, false);
                        _is.read(result, 4, false);
                    }
                    tars::Int32 _ret = getStateInfo(application,serverName,info,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("info", info);
                            tarsAttr.put("result", result);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(info, 3);
                            _os.write(result, 4);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 10:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    tars::Int32 count;
                    vector<tars::Int32> shm_keys;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("count", count);
                        tarsAttr.getByDefault("shm_keys", shm_keys, shm_keys);
                    }
                    else
                    {
                        _is.read(count, 1, true);
                        _is.read(shm_keys, 2, false);
                    }
                    tars::Int32 _ret = getUnusedShmKeys(count,shm_keys, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("shm_keys", shm_keys);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(shm_keys, 2);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 11:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("application", application);
                        tarsAttr.get("serverName", serverName);
                        tarsAttr.getByDefault("result", result, result);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(result, 3, false);
                    }
                    tars::Int32 _ret = loadServer(application,serverName,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("result", result);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 3);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 12:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string command;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("application", application);
                        tarsAttr.get("serverName", serverName);
                        tarsAttr.get("command", command);
                        tarsAttr.getByDefault("result", result, result);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(command, 3, true);
                        _is.read(result, 4, false);
                    }
                    tars::Int32 _ret = notifyServer(application,serverName,command,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("result", result);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 4);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 13:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    tars::PatchRequest req;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("req", req);
                        tarsAttr.getByDefault("result", result, result);
                    }
                    else
                    {
                        _is.read(req, 1, true);
                        _is.read(result, 2, false);
                    }
                    tars::Int32 _ret = patchPro(req,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("result", result);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 2);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 14:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.getByDefault("result", result, result);
                    }
                    else
                    {
                        _is.read(result, 1, false);
                    }
                    tars::Int32 _ret = shutdown(result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("result", result);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 1);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 15:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("application", application);
                        tarsAttr.get("serverName", serverName);
                        tarsAttr.getByDefault("result", result, result);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(result, 3, false);
                    }
                    tars::Int32 _ret = startServer(application,serverName,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("result", result);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 3);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 16:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.getByDefault("result", result, result);
                    }
                    else
                    {
                        _is.read(result, 1, false);
                    }
                    tars::Int32 _ret = stopAllServers(result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("result", result);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 1);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 17:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("application", application);
                        tarsAttr.get("serverName", serverName);
                        tarsAttr.getByDefault("result", result, result);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(result, 3, false);
                    }
                    tars::Int32 _ret = stopServer(application,serverName,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("result", result);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 3);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
                case 18:
                {
                    tars::TarsInputStream<tars::BufferReader> _is;
                    _is.setBuffer(_current->getRequestBuffer());
                    std::string application;
                    std::string serverName;
                    std::string result;
                    if (_current->getRequestVersion() == TUPVERSION)
                    {
                        UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                        tarsAttr.setVersion(_current->getRequestVersion());
                        tarsAttr.decode(_current->getRequestBuffer());
                        tarsAttr.get("application", application);
                        tarsAttr.get("serverName", serverName);
                        tarsAttr.getByDefault("result", result, result);
                    }
                    else
                    {
                        _is.read(application, 1, true);
                        _is.read(serverName, 2, true);
                        _is.read(result, 3, false);
                    }
                    tars::Int32 _ret = synState(application,serverName,result, _current);
                    if(_current->isResponse())
                    {
                        if (_current->getRequestVersion() == TUPVERSION )
                        {
                            UniAttribute<tars::BufferWriter, tars::BufferReader>  tarsAttr;
                            tarsAttr.setVersion(_current->getRequestVersion());
                            tarsAttr.put("", _ret);
                            tarsAttr.put("result", result);
                            tarsAttr.encode(_sResponseBuffer);
                        }
                        else
                        {
                            tars::TarsOutputStream<tars::BufferWriter> _os;
                            _os.write(_ret, 0);
                            _os.write(result, 3);
                            _os.swap(_sResponseBuffer);
                        }
                    }
                    return tars::TARSSERVERSUCCESS;

                }
            }
            return tars::TARSSERVERNOFUNCERR;
        }
    };


}



#endif
